// Copyright (c) 2025-2026 Roman Zhuzhgov
// Licensed under the Apache License, Version 2.0

@testable import Aether
import Foundation
import Testing

/// Validates @QuantumParameter property wrapper creation, value access,
/// projected value ($syntax), mutation, and auto-generated naming
/// for variational quantum circuit parameter declaration.
@Suite("QuantumParameter Creation and Access")
struct QuantumParameterCreationTests {
    @Test("Explicit name initializes parameter with given name")
    func explicitName() {
        @QuantumParameter(name: "theta") var theta = 0.5
        #expect(theta == 0.5, "wrappedValue should equal the initial value 0.5")
        #expect(_theta.parameter.name == "theta", "parameter name should be 'theta'")
    }

    @Test("Auto-generated name produces _qp-prefixed identifier")
    func autoGeneratedName() {
        @QuantumParameter var anonymous = 1.0
        #expect(_anonymous.parameter.name.hasPrefix("_qp"), "auto-generated name should start with '_qp'")
    }

    @Test("Two unnamed parameters receive distinct auto-generated names")
    func distinctAutoNames() {
        @QuantumParameter var a = 0.0
        @QuantumParameter var b = 0.0
        #expect(
            _a.parameter.name != _b.parameter.name,
            "two unnamed parameters must have different auto-generated names",
        )
    }

    @Test("wrappedValue returns the initial Double value")
    func wrappedValueAccess() {
        @QuantumParameter(name: "phi") var phi = 3.14
        #expect(abs(phi - 3.14) < 1e-10, "wrappedValue should be 3.14 within tolerance")
    }

    @Test("parameter property returns the symbolic Parameter with correct name")
    func parameterProperty() {
        @QuantumParameter(name: "gamma") var gamma = 0.7
        let param = _gamma.parameter
        #expect(param.name == "gamma", "parameter.name should be 'gamma'")
        #expect(param == Parameter(name: "gamma"), "parameter should equal Parameter(name: 'gamma')")
    }

    @Test("projectedValue ($syntax) yields ParameterValue.parameter case")
    func projectedValue() {
        @QuantumParameter(name: "beta") var beta = 1.0
        let projected = $beta
        #expect(projected.isSymbolic, "projected value should be symbolic")
        #expect(
            projected.parameter?.name == "beta",
            "projected value parameter name should be 'beta'",
        )
    }

    @Test("projectedValue evaluates to bound value via bindings dictionary")
    func projectedValueEvaluate() {
        @QuantumParameter(name: "alpha") var alpha = 2.5
        let projected = $alpha
        let evaluated = projected.evaluate(using: ["alpha": alpha])
        #expect(abs(evaluated - 2.5) < 1e-10, "evaluated projected value should match wrappedValue 2.5")
    }
}

/// Validates @QuantumParameter mutation behavior ensuring
/// wrappedValue updates propagate correctly while the symbolic
/// parameter identity remains unchanged after mutation.
@Suite("QuantumParameter Mutation")
struct QuantumParameterMutationTests {
    @Test("Mutating wrappedValue updates the stored Double")
    func mutateWrappedValue() {
        @QuantumParameter(name: "theta") var theta = 0.0
        theta = 1.57
        #expect(abs(theta - 1.57) < 1e-10, "wrappedValue should be 1.57 after mutation")
    }

    @Test("Parameter identity is preserved after wrappedValue mutation")
    func parameterIdentityPreserved() {
        @QuantumParameter(name: "phi") var phi = 0.0
        let paramBefore = _phi.parameter
        phi = 3.14
        let paramAfter = _phi.parameter
        #expect(paramBefore == paramAfter, "parameter should remain the same after mutating wrappedValue")
        #expect(paramAfter.name == "phi", "parameter name should still be 'phi' after mutation")
    }

    @Test("Multiple mutations track latest value correctly")
    func multipleMutations() {
        @QuantumParameter(name: "delta") var delta = 0.0
        delta = 1.0
        delta = 2.0
        delta = 3.0
        #expect(abs(delta - 3.0) < 1e-10, "wrappedValue should be 3.0 after three mutations")
    }
}

/// Validates @Qubit property wrapper initialization with valid indices,
/// correct wrappedValue access, and usage as qubit index
/// references in quantum circuit gate operations.
@Suite("Qubit Property Wrapper")
struct QubitPropertyWrapperTests {
    @Test("Creation with valid index stores correct wrappedValue")
    func validIndex() {
        @Qubit var q0 = 0
        #expect(q0 == 0, "wrappedValue should be 0 for qubit index 0")
    }

    @Test("Higher qubit index stores correctly")
    func higherIndex() {
        @Qubit var q5 = 5
        #expect(q5 == 5, "wrappedValue should be 5 for qubit index 5")
    }

    @Test("Multiple qubit declarations produce independent indices")
    func multipleQubits() {
        @Qubit var control = 0
        @Qubit var target = 1
        #expect(control == 0, "control qubit should be index 0")
        #expect(target == 1, "target qubit should be index 1")
        #expect(control != target, "control and target should have different indices")
    }

    @Test("Qubit index used in circuit append operation")
    func usedInCircuitAppend() {
        @Qubit var q0 = 0
        @Qubit var q1 = 1
        var circuit = QuantumCircuit(qubits: 2)
        circuit.append(.hadamard, to: q0)
        circuit.append(.pauliX, to: q1)
        #expect(circuit.count == 2, "circuit should have 2 operations after appending to qubit indices")
    }

    @Test("Qubit index used in multi-qubit gate operation")
    func usedInMultiQubitGate() {
        @Qubit var control = 0
        @Qubit var target = 1
        var circuit = QuantumCircuit(qubits: 2)
        circuit.append(.cnot, to: [control, target])
        #expect(circuit.count == 1, "circuit should have 1 CNOT operation")
    }
}

/// Validates integration of @QuantumParameter with QuantumCircuit
/// for symbolic parameter binding, circuit construction, and
/// end-to-end variational circuit workflows.
@Suite("QuantumParameter Circuit Integration")
struct QuantumParameterIntegrationTests {
    @Test("@QuantumParameter builds parameterized circuit with symbolic gate")
    func parameterizedCircuitConstruction() {
        @QuantumParameter(name: "theta") var theta = 0.5
        var circuit = QuantumCircuit(qubits: 1)
        circuit.append(.rotationY($theta), to: 0)
        #expect(circuit.count == 1, "circuit should have 1 operation")
        #expect(circuit.parameters.count == 1, "circuit should have 1 symbolic parameter")
        #expect(
            circuit.parameters.first?.name == "theta",
            "circuit parameter name should be 'theta'",
        )
    }

    @Test("Binding @QuantumParameter value resolves symbolic circuit")
    func bindParameterValue() {
        @QuantumParameter(name: "phi") var phi = 0.785
        var circuit = QuantumCircuit(qubits: 1)
        circuit.append(.rotationY($phi), to: 0)
        let bound = circuit.binding(["phi": phi])
        #expect(bound.parameters.isEmpty, "bound circuit should have no symbolic parameters")
        #expect(bound.count == 1, "bound circuit should still have 1 operation")
    }

    @Test("Multiple @QuantumParameter values in same circuit bind independently")
    func multipleParametersBinding() {
        @QuantumParameter(name: "alpha") var alpha = 0.3
        @QuantumParameter(name: "beta") var beta = 0.7
        var circuit = QuantumCircuit(qubits: 2)
        circuit.append(.rotationY($alpha), to: 0)
        circuit.append(.rotationZ($beta), to: 1)
        #expect(circuit.parameters.count == 2, "circuit should have 2 symbolic parameters")
        let bound = circuit.binding(["alpha": alpha, "beta": beta])
        #expect(bound.parameters.isEmpty, "bound circuit should have no remaining symbolic parameters")
    }

    @Test("@QuantumParameter with @Qubit in circuit workflow")
    func parameterAndQubitTogether() {
        @QuantumParameter(name: "angle") var angle = 1.57
        @Qubit var q = 0
        var circuit = QuantumCircuit(qubits: 1)
        circuit.append(.rotationX($angle), to: q)
        #expect(circuit.count == 1, "circuit should have 1 operation using @Qubit index")
        #expect(
            circuit.parameters.first?.name == "angle",
            "circuit parameter should be named 'angle' from @QuantumParameter",
        )
    }

    @Test("Mutated @QuantumParameter value binds with updated value")
    func mutatedParameterBinding() {
        @QuantumParameter(name: "theta") var theta = 0.0
        var circuit = QuantumCircuit(qubits: 1)
        circuit.append(.rotationY($theta), to: 0)
        theta = 1.57
        let bound = circuit.binding(["theta": theta])
        #expect(bound.parameters.isEmpty, "bound circuit should have no symbolic parameters after binding mutated value")
    }
}
